!***************************************************************************************************
!
! To grid Radiance data, namely those TB from FWD files.
! Control file:
!
!	data/ControlData/n18_FWDGrid_2010-08-15.in_gdas
!
! Input files, FWD files:
!
!	data/TestbedData/DynamicData/fwd_analys/n18_amsua_mhs/2010-08-15/FWD_GDAS.NN.D10227.S0152.E0347.B2697475.WI.LR
!	
! Output, Gridded Radius (FWD) files ( FWD == RAD ):
!	GRID_n18_gdas_20100815_tb_as.dat      ( RAD%tb )
!	GRID_n18_gdas_20100815_angle_as.dat
!	
! Output to be used by fortran program: src/testbed/grid/gridBias.f90 to compute bias of clear-sky corrected TB
!        and simulated TB:
!  line 179:
!  fileRad   = 'GRID_'//trim(satId)//'_'//trim(nwpString)//'_'//trim(yyyymmdd)//'_tb_'//cends(icend)//'.dat'
!	       GRID_n18_gdas_20100815_tb_as.dat
!  ==> gridded bias file:
!  fileBias  = 'GRID_'//trim(satId)//'_rad_'//trim(nwpString)//'_bias_'//trim(yyyymmdd)//&
!               '_'//trim(prods5(iprod))//'_'//cends(icend)//'.dat'
!               GRID_n18_gdas_bias_20100815_tbl_as.dat ( to be used by gridRad.pro )
!  
!  note: fileMirs  = 'GRID_'//trim(satId)//'_'//trim(yyyymmdd)//'_'//trim(prods5(iprod))//'_'//cends(icend)//'.dat' 
!  	is generated by src/testbed/grid/griEdr.f90
!		 
! Output to be used by IDL program: src/testbed/grid/gridRad.pro
!	map
!	GRID_n18_gdas_20100815_tb_as.dat --> MIRS N18 Simulated Brightness Temperature using GDAS
!	http://www.orbit2.nesdis.noaa.gov/corp/scsb/mirs/images/n18/2010-08-14/mirs_adv_poes_n18_gdas_glb_20100815_tb_23v_all_as.png
!
! 
!  Wanchun Chen      10/10/2007         Original Coder
!
!***************************************************************************************************

Program gridRad

  USE Consts
  USE misc
  USE IO_MeasurData
  USE IO_Misc
  USE ErrorHandling
  
  IMPLICIT NONE
  !---INTRINSIC functions used in this module
  INTRINSIC :: ABS,COS,INT,MOD,TRIM,ALLOCATED

  INTEGER            :: iu_list=20,iuRAD,ierr,iprof,nprf
  INTEGER, PARAMETER :: lenf=256
  INTEGER            :: ifile, nfiles
  CHARACTER(LEN=lenf), DIMENSION(:), POINTER  :: inputFiles, dumFiles 
  
  !---Structures
  TYPE(MeasurData_type)  :: Rad
  
  INTEGER                :: NCHAN=20, ichan
  INTEGER                :: NCOL, NROW
  CHARACTER(LEN=lenf)    :: gridFile
  LOGICAL                :: nadirLogic_as=.FALSE., nadirLogic_ds=.FALSE.
  INTEGER                :: INT_SATID=SENSOR_ID_N18
  
  !----namelist data
  CHARACTER(LEN=lenf) :: filesList=DEFAULT_VALUE_STR4
  CHARACTER(LEN=8)    :: satId=DEFAULT_VALUE_STR4  ! n18, m2, f16, n19, npp
  CHARACTER(LEN=64)   :: yyyymmdd=DEFAULT_VALUE_STR4
  REAL                :: gridfactor=DEFAULT_VALUE_INT
  CHARACTER(LEN=lenf) :: gridPath=DEFAULT_VALUE_STR4
  REAL                :: latmin=DEFAULT_VALUE_REAL
  REAL                :: latmax=DEFAULT_VALUE_REAL
  REAL                :: lonmin=DEFAULT_VALUE_REAL
  REAL                :: lonmax=DEFAULT_VALUE_REAL
  INTEGER             :: isMirs=DEFAULT_VALUE_INT  ! 0(MIRS EDR), 1(gdas), 2(ecmwf), 3(gfs)
  INTEGER             :: fmType=0
  
  NAMELIST /gridRadNameList/filesList,satId,yyyymmdd,gridfactor,gridPath,latmin,latmax,lonmin,lonmax,isMirs,fmType
  
  !-------------------------------------------------------------------------------
  !     Output variables identifiers definiton section, commented part from DEP
  !-------------------------------------------------------------------------------
  REAL, DIMENSION(:,:,:), ALLOCATABLE   :: angle_grid_as, angle_grid_ds 
  REAL, DIMENSION(:,:,:), ALLOCATABLE   :: tb_grid_as, tb_grid_ds
  INTEGER, DIMENSION(:,:), ALLOCATABLE  :: nadir_as, nadir_ds 
  
  
  !-----------------------------------------------------
  !     grid and fill in stuff goes here
  !-----------------------------------------------------
  REAL          :: RSAT=833.0
  INTEGER       :: NFOV=30
  REAL          :: SCAN_ANG=3.3
  INTEGER       :: LATLIM_A=12
  REAL          :: FIX=0.5
  REAL          :: loncorr
  INTEGER       :: ifov
  REAL          :: lonleft, lonright
  INTEGER       :: gridlon_left, gridlon_right
  INTEGER       :: gridlat_bot, gridlat_top
  INTEGER       :: lonbox, latbox, near_nadir
  REAL,   DIMENSION(:), ALLOCATABLE :: fov_size


  !-----------------------------------------------------
  !     Execute section begins here
  !-----------------------------------------------------
  
  READ(*,NML=gridRadNameList)
  ! string type satellite id --> integer type satellite id
  if      ( strcmp(satId, SATID_F16)    .eq. 0 ) then
      INT_SATID = SENSOR_ID_F16
      NCHAN=24
      if( fmType .eq. 0 ) then
        NFOV=30
      else if( fmType .eq. 1 ) then
        NFOV=60
      else if( fmType .eq. 2 ) then
        NFOV=90
      else if( fmType .eq. 3 ) then
        NFOV=180
      else
        STOP 'Error: Incorrect fmType for F16'
      endif
      
  else if ( strcmp(satId, SATID_F17)    .eq. 0 ) then
      INT_SATID = SENSOR_ID_F17
      NCHAN=24
      if( fmType .eq. 0 ) then
        NFOV=30
      else if( fmType .eq. 1 ) then
        NFOV=60
      else if( fmType .eq. 2 ) then
        NFOV=90
      else if( fmType .eq. 3 ) then
        NFOV=180
      else
        STOP 'Error: Incorrect fmType for F17'
      endif
      
  else if ( strcmp(satId, SATID_F18)    .eq. 0 ) then
      INT_SATID = SENSOR_ID_F18
      NCHAN=24
      if( fmType .eq. 0 ) then
        NFOV=30
      else if( fmType .eq. 1 ) then
        NFOV=60
      else if( fmType .eq. 2 ) then
        NFOV=90
      else if( fmType .eq. 3 ) then
        NFOV=180
      else
        STOP 'Error: Incorrect fmType for F18'
      endif
      
  else if ( strcmp(satId, SATID_N18)    .eq. 0 ) then
      INT_SATID = SENSOR_ID_N18
      NCHAN=20
      if( fmType .eq. 0 ) then
        NFOV=30
        SCAN_ANG=3.3
      else if( fmType .eq. 1 ) then
        NFOV=90
        SCAN_ANG=1.1
      else
        STOP 'Error: Incorrect fmType for N18'
      endif
      
  else if ( strcmp(satId, SATID_N19)    .eq. 0 ) then
      INT_SATID = SENSOR_ID_N19
      NCHAN=20
      if( fmType .eq. 0 ) then
        NFOV=30
        SCAN_ANG=3.3
      else if( fmType .eq. 1 ) then
        NFOV=90
        SCAN_ANG=1.1
      else
        STOP 'Error: Incorrect fmType for N19'
      endif
 
  else if ( strcmp(satId, SATID_METOPA) .eq. 0 ) then
      INT_SATID = SENSOR_ID_METOPA
      NCHAN=20
      if( fmType .eq. 0 ) then
        NFOV=30
        SCAN_ANG=3.3
      else if( fmType .eq. 1 ) then
        NFOV=90
        SCAN_ANG=1.1
      else
        STOP 'Error: Incorrect fmType for metopA'
      endif
 
  else if ( strcmp(satId, SATID_METOPB) .eq. 0 ) then
      INT_SATID = SENSOR_ID_METOPB
      NCHAN=20
      if( fmType .eq. 0 ) then
        NFOV=30
        SCAN_ANG=3.3
      else if( fmType .eq. 1 ) then
        NFOV=90
        SCAN_ANG=1.1
      else
        STOP 'Error: Incorrect fmType for metopB'
      endif
      
  else if ( strcmp(satId, SATID_NPP)    .eq. 0 ) then
      INT_SATID = SENSOR_ID_NPP
      NCHAN=22
      NFOV=32
      RSAT=824.0
      if ( fmType .eq. 0 ) then
         NFOV=32
         SCAN_ANG=3.3
      else if ( fmType .eq. 1 ) then
         NFOV=96
         SCAN_ANG=1.1
      else
         STOP 'Error: Incorrect fmType for NPP ATMS'
      endif

  else if ( strcmp(satId, SATID_AMSRE)  .eq. 0 ) then
      INT_SATID = SENSOR_ID_AMSRE
      NCHAN = 12
      NFOV = 191

  else if ( strcmp(satId, SATID_GCOMW1)   .eq. 0 ) then
      INT_SATID = SENSOR_ID_GCOMW1
      NCHAN = 14
      if( fmType .eq. -1 ) then
        NFOV=27
      else if( fmType .eq. 0 ) then
        NFOV=243
      else if( fmType .eq. 1 ) then
        NFOV=486
      else
        STOP 'Error: Incorrect fmType for GCOMW1 AMSR2'
      endif

  else if ( strcmp(satId, SATID_FY3RI)  .eq. 0 ) then
      INT_SATID = SENSOR_ID_FY3RI
      NCHAN = 10
      NFOV = 120

  else if ( strcmp(satId, SATID_TRMM)   .eq. 0 ) then
      INT_SATID = SENSOR_ID_TRMM
      NCHAN = 9
      NFOV = 26
      if( fmType .eq. -1 ) then
        NFOV=26
      else if( fmType .eq. 0 ) then
        NFOV=104
      else if( fmType .eq. 1 ) then
        NFOV=208
      else
        STOP 'Error: Incorrect fmType for TRMM TMI'
      endif

  else if ( strcmp(satId, SATID_GPM)   .eq. 0 ) then
      INT_SATID = SENSOR_ID_GPM
      NCHAN = 13
      NFOV = 26
      if( fmType .eq. -1 ) then
        NFOV=26
      else if( fmType .eq. 0 ) then
        NFOV=104
      else if( fmType .eq. 1 ) then
        NFOV=208
      else
        STOP 'Error: Incorrect fmType for GPM GMI'
      endif

! For MT MADRAS proxy data use same params as TRMM TMI
! This will need to be changed when processing real data

  else if ( strcmp(satId, SATID_MTMA)   .eq. 0 ) then
      INT_SATID = SENSOR_ID_MTMA
      NCHAN = 9
      NFOV = 60
!      if( fmType .eq. -1 ) then
!        NFOV=60
!      else if( fmType .eq. 0 ) then
!        NFOV=240
!      else if( fmType .eq. 1 ) then
!        NFOV=480
!      else
!        STOP 'Error: Incorrect fmType for MT MADRAS'
!      endif
      if( fmType .eq. -1 ) then
        NFOV=27
      else if( fmType .eq. 0 ) then
        NFOV=107
      else if( fmType .eq. 1 ) then
        NFOV=214
      else
        STOP 'Error: Incorrect fmType for MT MADRAS'
      endif

! For now, MT SAPHIR proxy data uses same params as N18_AMSUA_MHS
! This will need to be changed when real data are processed
  else if( strcmp(satId, SATID_MTSA)    .eq. 0 ) then
      INT_SATID = SENSOR_ID_MTSA
      NCHAN=6
!      if( fmType .eq. -1 ) then
!        NFOV=45
!        SCAN_ANG=3.3
!      else if( fmType .eq. 0 ) then
!        NFOV=91
!        SCAN_ANG=2.2
!      else if( fmType .eq. 1 ) then
!        NFOV=182
!        SCAN_ANG=1.1
!      else
!        STOP 'Error: Incorrect fmType for MT SAPHIR'
!      endif
      if( fmType .eq. -1 ) then
        NFOV=26
        SCAN_ANG=3.3
      else if( fmType .eq. 0 ) then
        NFOV=65
        SCAN_ANG=2.2
      else if( fmType .eq. 1 ) then
        NFOV=130
        SCAN_ANG=1.1
      else
        STOP 'Error: Incorrect fmType for MT SAPHIR'
      endif
      
  endif
  
  !-----------------------------------------------------
  !     Compute FOV size for filling purpose
  !-----------------------------------------------------
  IF (.NOT.ALLOCATED(fov_size)) ALLOCATE(fov_size(0:NFOV-1))
  if( INT_SATID .eq. SENSOR_ID_N18 .or. INT_SATID .eq. SENSOR_ID_METOPA .or. &
      INT_SATID .eq. SENSOR_ID_N19 .or. INT_SATID .eq. SENSOR_ID_METOPB .or. &
      INT_SATID .eq. SENSOR_ID_NPP ) then
    call get_fov_size(fov_size,NFOV,SCAN_ANG,RSAT)
  else if(INT_SATID .eq. SENSOR_ID_F16 .or. INT_SATID .eq. SENSOR_ID_F18 .or. &
           INT_SATID .eq. SENSOR_ID_F17 ) then
    fov_size(:) = 0.6745
  else
    fov_size(:) = 1.0
  endif

  call ReadList(iu_list, trim(filesList), inputFiles, nfiles, dumFiles, '', '')
  IF (nfiles .lt. 1) CALL ErrHandl(ErrorType,Err_NoFilesFound,'') 
  

  !-----------------------------------------------------
  !     Allocate output array and initialize them
  !-----------------------------------------------------
  NCOL=int(360*gridfactor)
  NROW=int(180*gridfactor)

  ALLOCATE ( angle_grid_as ( 0:NCOL-1, 0:NROW-1, 1:NCHAN ) )
  ALLOCATE ( angle_grid_ds ( 0:NCOL-1, 0:NROW-1, 1:NCHAN ) )  
  
  ALLOCATE ( tb_grid_as ( 0:NCOL-1, 0:NROW-1, 1:NCHAN) )
  ALLOCATE ( tb_grid_ds ( 0:NCOL-1, 0:NROW-1, 1:NCHAN) )

  ALLOCATE ( nadir_as ( 0:NCOL-1, 0:NROW-1 ) )  
  ALLOCATE ( nadir_ds ( 0:NCOL-1, 0:NROW-1 ) )  

  angle_grid_as = -999.0
  angle_grid_ds = -999.0
  
  tb_grid_as = -999.0
  tb_grid_ds = -999.0

  nadir_as = NFOV
  nadir_ds = NFOV

  write(*,*) 'grid tb ( NWP simulated tb from FWD files, Rad%tb-> gridded tb )'
  write(*,*)
  
  !-----------------------------------------------------
  !     Loop over the EDR files
  !-----------------------------------------------------
  FilesLoop: DO ifile=1,nfiles
  
    write(*,'(A)') trim(inputFiles(ifile))

    !---Read header of EDR file
    CALL ReadHdrMeasurmts(inputFiles(ifile),iuRAD,nprf,Rad)

    !---Loop over the profiles within the file
    ProfilesLoop: DO iprof=1,nPrf
        CALL ReadMeasurmts(iuRAD,Rad,ierr)
 
        IF (ierr.eq.Warn_EndOfFile)   EXIT  ProfilesLoop
        IF (ierr.eq.Warn_readInvalid) CYCLE ProfilesLoop
        IF (ierr.ne.0) CALL ErrHandl(ErrorType,Err_ReadingFile,'. Rad file.')

        loncorr=abs(1/cos(PI*Rad%lat/180.0))
        if ( loncorr .gt. 200 ) loncorr=200
        ifov = MOD( iprof, NFOV )

        IF ( INT_SATID .eq. SENSOR_ID_N18 .or. INT_SATID .eq. SENSOR_ID_METOPA .or. &
             INT_SATID .eq. SENSOR_ID_N19 .or. INT_SATID .eq. SENSOR_ID_METOPB .or. &
             INT_SATID .eq. SENSOR_ID_NPP ) THEN

          lonleft  = Rad%lon - 0.5 * fov_size(ifov) * loncorr
          lonright = Rad%lon + 0.5 * fov_size(ifov) * loncorr
          gridlon_left  = INT((lonleft  + 180.0) * gridfactor + fix)
          gridlon_right = INT((lonright + 180.0) * gridfactor + fix)

          if( fmType .eq. 0 ) then
            if ( abs(ifov-(NFOV-1.)/2.) .lt. (LATLIM_A - 0.4 )) then
                gridlat_bot = INT((Rad%lat+90) * gridfactor)
                gridlat_top = gridlat_bot + 1 
            else 
                gridlat_bot = INT((Rad%lat+90.0) * gridfactor - 1 + fix)
                gridlat_top = INT((Rad%lat+90.0) * gridfactor + 1 + fix)
            endif
          else
            gridlat_bot = INT((Rad%lat+90) * gridfactor) 
            gridlat_top = INT((Rad%lat+90) * gridfactor) 
	  endif

        ELSE IF ( INT_SATID .eq. SENSOR_ID_F16 .or. INT_SATID .eq. SENSOR_ID_F18 .or. &
	           INT_SATID .eq. SENSOR_ID_F17 ) THEN
        
          lonleft  = Rad%lon - 0.5 * fov_size(ifov) * loncorr
          lonright = Rad%lon + 0.5 * fov_size(ifov) * loncorr
          gridlon_left  = INT((lonleft  + 180.0) * gridfactor + fix)
          gridlon_right = INT((lonright + 180.0) * gridfactor + fix)
  
          gridlat_bot = INT((Rad%lat+90.0) * gridfactor - 1 + fix)
          gridlat_top = INT((Rad%lat+90.0) * gridfactor + 1 + fix)
  
          !--- For now do same filling for MT SAPHIR as for N18, but may need to change with real data

        ELSE IF ( INT_SATID .eq. SENSOR_ID_MTSA ) THEN
        
          lonleft  = Rad%lon - 0.5 * fov_size(ifov) * loncorr
          lonright = Rad%lon + 0.5 * fov_size(ifov) * loncorr
          gridlon_left  = INT((lonleft  + 180.0) * gridfactor + fix)
          gridlon_right = INT((lonright + 180.0) * gridfactor + fix)

          if( fmType .eq. 0 ) then
            if ( abs(ifov-(NFOV-1.)/2.) .lt. (LATLIM_A - 0.4 )) then
                gridlat_bot = INT((Rad%lat+90) * gridfactor)
                gridlat_top = gridlat_bot + 1 
            else 
                gridlat_bot = INT((Rad%lat+90.0) * gridfactor - 1 + fix)
                gridlat_top = INT((Rad%lat+90.0) * gridfactor + 1 + fix)
            endif
          else
            gridlat_bot = INT((Rad%lat+90) * gridfactor) 
            gridlat_top = INT((Rad%lat+90) * gridfactor) 
	  endif

        ELSE  ! NO FILLING

          gridlon_left  = INT((Rad%lon + 180.0) * gridfactor + fix)
          gridlon_right = INT((Rad%lon + 180.0) * gridfactor + fix)
          gridlat_bot   = INT((Rad%lat + 90.0 ) * gridfactor + fix)
          gridlat_top   = INT((Rad%lat + 90.0 ) * gridfactor + fix)

        ENDIF

        if ( gridlon_left  .lt. 0    ) gridlon_left=0
        if ( gridlon_left  .ge. NCOL ) gridlon_left=NCOL-1
        if ( gridlon_right .lt. 0    ) gridlon_right=0
        if ( gridlon_right .ge. NCOL ) gridlon_right=NCOL-1

        if ( gridlat_bot   .lt. 0    ) gridlat_bot=0
        if ( gridlat_top   .lt. 0    ) gridlat_top=0
        if ( gridlat_top   .ge. NROW ) gridlat_top=NROW-1
        if ( gridlat_bot   .ge. NROW ) gridlat_bot=NROW-1

        near_nadir = INT(abs(ifov - (NFOV-1.)/2.) + 0.6)

        do latbox=gridlat_bot,  gridlat_top
        do lonbox=gridlon_left, gridlon_right

            !---- Ascending 
            nadirLogic_as = near_nadir .le. nadir_as(lonbox,latbox)
            if( INT_SATID .eq. SENSOR_ID_AMSRE .or. INT_SATID .eq. SENSOR_ID_FY3RI .or. &
                INT_SATID .eq. SENSOR_ID_TRMM  .or. INT_SATID .eq. SENSOR_ID_GPM  .or. &
                INT_SATID .eq. SENSOR_ID_MTMA ) nadirLogic_as = .TRUE.
           
            if ( Rad%node .eq. 0 .and. nadirLogic_as ) then
                nadir_as(lonbox,latbox) = near_nadir
                angle_grid_as(lonbox,latbox,1:NCHAN) = Rad%Angle
                tb_grid_as(lonbox,latbox,1:NCHAN)    = Rad%tb
            endif

            !---- Descending 
            nadirLogic_ds = near_nadir .le. nadir_ds(lonbox,latbox)
            if( INT_SATID .eq. SENSOR_ID_AMSRE .or. INT_SATID .eq. SENSOR_ID_FY3RI .or. &
                INT_SATID .eq. SENSOR_ID_TRMM  .or. INT_SATID .eq. SENSOR_ID_GPM  .or. &
                INT_SATID .eq. SENSOR_ID_MTMA ) nadirLogic_ds = .TRUE.
            
            if ( Rad%node .eq. 1 .and. nadirLogic_ds ) then
                nadir_ds(lonbox,latbox) = near_nadir
                angle_grid_ds(lonbox,latbox,1:NCHAN) = Rad%Angle
                tb_grid_ds(lonbox,latbox,1:NCHAN)    = Rad%tb
            endif

        enddo
        enddo 

    ENDDO ProfilesLoop
   
    !---Close the Rad file
    CLOSE (iuRAD)
    !---Release memory
    DEALLOCATE(Rad%CentrFreq,Rad%Rad,Rad%qc,Rad%Tb,Rad%polar,Rad%angle,Rad%secant_view)
  
  ENDDO FilesLoop


  !-----------------------------------------------------
  !     writeout the data
  !-----------------------------------------------------
  
  if ( isMirs .eq. 1 ) gridFile='GRID_'//trim(satId)//'_gdas_'//trim(yyyymmdd)//'_tb_as.dat'
  if ( isMirs .eq. 2 ) gridFile='GRID_'//trim(satId)//'_ecmwf_'//trim(yyyymmdd)//'_tb_as.dat'
  if ( isMirs .eq. 3 ) gridFile='GRID_'//trim(satId)//'_gfs_'//trim(yyyymmdd)//'_tb_as.dat'
  write(*,'(A)')'grid file='//trim(gridPath)//trim(gridFile)
  open(25,file=trim(gridPath)//trim(gridFile),form='unformatted', access='direct', recl=4*NCOL*NROW)
  do ichan=1,NCHAN
    write(25,rec=ichan)tb_grid_as(0:NCOL-1, 0:NROW-1, ichan)
  enddo
  close(25)
 
  if ( isMirs .eq. 1 ) gridFile='GRID_'//trim(satId)//'_gdas_'//trim(yyyymmdd)//'_tb_ds.dat'
  if ( isMirs .eq. 2 ) gridFile='GRID_'//trim(satId)//'_ecmwf_'//trim(yyyymmdd)//'_tb_ds.dat'
  if ( isMirs .eq. 3 ) gridFile='GRID_'//trim(satId)//'_gfs_'//trim(yyyymmdd)//'_tb_ds.dat'
  write(*,'(A)')'grid file='//trim(gridPath)//trim(gridFile)
  open(25,file=trim(gridPath)//trim(gridFile),form='unformatted', access='direct', recl=4*NCOL*NROW)
  do ichan=1,NCHAN
    write(25,rec=ichan)tb_grid_ds(0:NCOL-1, 0:NROW-1, ichan)
  enddo
  close(25)
  
  if ( isMirs .eq. 1 ) gridFile='GRID_'//trim(satId)//'_gdas_'//trim(yyyymmdd)//'_angle_as.dat'
  if ( isMirs .eq. 2 ) gridFile='GRID_'//trim(satId)//'_ecmwf_'//trim(yyyymmdd)//'_angle_as.dat'
  if ( isMirs .eq. 3 ) gridFile='GRID_'//trim(satId)//'_gfs_'//trim(yyyymmdd)//'_angle_as.dat'
  open(25,file=trim(gridPath)//gridFile,form='unformatted', access='direct', recl=4*NCOL*NROW)
  do ichan=1,NCHAN
    write(25,rec=ichan)angle_grid_as(0:NCOL-1, 0:NROW-1, ichan)
  enddo
  close(25)
 
  if ( isMirs .eq. 1 ) gridFile='GRID_'//trim(satId)//'_gdas_'//trim(yyyymmdd)//'_angle_ds.dat'
  if ( isMirs .eq. 2 ) gridFile='GRID_'//trim(satId)//'_ecmwf_'//trim(yyyymmdd)//'_angle_ds.dat'
  if ( isMirs .eq. 3 ) gridFile='GRID_'//trim(satId)//'_gfs_'//trim(yyyymmdd)//'_angle_ds.dat'
  open(25,file=trim(gridPath)//gridFile,form='unformatted', access='direct', recl=4*NCOL*NROW)
  do ichan=1,NCHAN
    write(25,rec=ichan)angle_grid_ds(0:NCOL-1, 0:NROW-1, ichan)
  enddo
  close(25)
  
  !-----------------------------------------------------
  !      Release memory
  !-----------------------------------------------------
  DEALLOCATE(inputFiles)
  DEALLOCATE(dumFiles)
  DEALLOCATE(fov_size)

  DEALLOCATE(angle_grid_as)
  DEALLOCATE(angle_grid_ds)  
  
  DEALLOCATE(tb_grid_as)
  DEALLOCATE(tb_grid_ds)

  DEALLOCATE(nadir_as)  
  DEALLOCATE(nadir_ds)  

end program gridRad
